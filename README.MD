# Network Filtering Experiment

**Syst√®me de filtrage r√©seau exp√©rimental pour comparer les approches s√©quentielle vs parall√®le**

Projet de Master en G√©nie Informatique - DONFACK PASCAL ARTHUR MONTGOMERY  
Encadreurs : Dr HYPPOLITE MICHEL TAPAMO KENFACK & Dr DJOB MVONDO

---

## üéØ Objectif du Projet

Ce projet vise √† r√©soudre un probl√®me concret dans la s√©curit√© r√©seau : **la latence excessive caus√©e par l'empilement de filtres r√©seau** (IPS, WAF, Firewalls).

### Le Probl√®me
Quand on empile plusieurs filtres de s√©curit√© r√©seau :
```
Client ‚Üí IPS ‚Üí WAF ‚Üí Firewall ‚Üí Serveur
```

**R√©sultat :** Un paquet peut traverser toute la cha√Æne avant d'√™tre rejet√© √† la fin, gaspillant des ressources CPU et r√©seau.

### Notre Solution
Cr√©er un **filtreur unifi√©** qui :
- R√©cup√®re les r√®gles de tous les filtres existants
- Les applique **t√¥t** dans la cha√Æne pour rejeter les paquets malveillants avant qu'ils traversent tout
- Compare deux approches : **s√©quentielle** vs **parall√®le/hybride**

---

## üèóÔ∏è Architecture Technique

### Vue d'ensemble
```
Paquets r√©seau ‚Üí NFQUEUE ‚Üí Tiger-Fox ‚Üí DROP/ACCEPT
                     ‚Üì
                [Rule Engine]
                     ‚Üì
            [S√©quentiel | Hybride]
```

### Composants Principaux

#### 1. **NFQUEUE** - Interface R√©seau
- M√©canisme Linux qui intercepte les paquets via iptables
- Permet de d√©cider en temps r√©el : DROP ou ACCEPT
- Interface entre le kernel Linux et notre application Python

#### 2. **Rule Engine** - Moteur de R√®gles
- **Mode S√©quentiel** : V√©rifie les r√®gles une par une (L3 ‚Üí L4 ‚Üí L7)
- **Mode Hybride** : V√©rifie toutes les couches en parall√®le avec des threads

#### 3. **Parser de Paquets**
- Analyse les paquets r√©seau pour extraire :
  - **Layer 3** : IP source/destination, protocole
  - **Layer 4** : Ports TCP/UDP, flags
  - **Layer 7** : HTTP (URI, headers, m√©thodes)

#### 4. **Syst√®me de M√©triques**
- Mesure en temps r√©el : latence, throughput, CPU
- Compare les performances entre les deux modes

---

## üìÅ Structure du Projet

```
tiger-foxx-experiment-filtering/
‚îú‚îÄ‚îÄ README.md                    # Ce fichier
‚îú‚îÄ‚îÄ config.yaml                 # Configuration du syst√®me
‚îú‚îÄ‚îÄ main.py                     # Point d'entr√©e principal
‚îú‚îÄ‚îÄ requirements.txt            # D√©pendances Python
‚îú‚îÄ‚îÄ engine/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ metrics.py              # Collecte de m√©triques
‚îÇ   ‚îú‚îÄ‚îÄ packet_handler.py       # Gestion NFQUEUE
‚îÇ   ‚îú‚îÄ‚îÄ packet_parser.py        # Analyse des paquets
‚îÇ   ‚îî‚îÄ‚îÄ rule_engine.py          # Moteur de r√®gles
‚îî‚îÄ‚îÄ rules/
    ‚îú‚îÄ‚îÄ example_rules.json      # R√®gles d'exemple
    ‚îî‚îÄ‚îÄ rule_loader.py          # Chargement des r√®gles
```

---

## üîß Installation et Configuration

### Pr√©requis Syst√®me
- **Linux** (Ubuntu 20.04+ recommand√©)
- **Python 3.8+**
- **Droits root** (requis pour NFQUEUE)

### 1. Installer les D√©pendances
```bash
# Installer les outils syst√®me
sudo apt update
sudo apt install python3-pip iptables-dev libnetfilter-queue-dev

# Cloner le projet
git clone <votre-repo>
cd tiger-foxx-experiment-filtering

# Installer les d√©pendances Python
sudo pip install -r requirements.txt
```

### 2. Configurer iptables
```bash
# Rediriger le trafic HTTP vers NFQUEUE
sudo iptables -I INPUT -p tcp --dport 80 -j NFQUEUE --queue-num 0

# Ou pour tout le trafic (attention !)
sudo iptables -I INPUT -j NFQUEUE --queue-num 0
```

### 3. Configuration du Syst√®me
Modifier `config.yaml` selon vos besoins :
```yaml
engine:
  mode: "sequential"     # "sequential" ou "hybrid"
  queue_num: 0          # Num√©ro de queue NFQUEUE
  
performance:
  enable_metrics: true  # Activer la collecte de m√©triques
  metric_interval: 1.0  # Intervalle en secondes

rules:
  file: "rules/example_rules.json"  # Fichier de r√®gles
```

---

## üöÄ Utilisation

### Lancement Basique
```bash
# Mode s√©quentiel
sudo python main.py --mode sequential

# Mode hybride (parall√®le)
sudo python main.py --mode hybrid

# Avec logs d√©taill√©s
sudo python main.py --mode sequential --verbose
```

### Options Avanc√©es
```bash
# Utiliser un fichier de r√®gles personnalis√©
sudo python main.py --rules mes_regles.json

# Changer le num√©ro de queue
sudo python main.py --queue 1

# Afficher l'aide
python main.py --help
```

### Arr√™t du Syst√®me
```bash
# Ctrl+C pour arr√™ter le syst√®me
# Puis nettoyer iptables :
sudo iptables -D INPUT -j NFQUEUE --queue-num 0
```

---

## üìä Tests et √âvaluation

### 1. G√©n√©rer du Trafic de Test

#### Avec wrk (HTTP)
```bash
# Installer wrk
sudo apt install wrk

# Test de charge basique
wrk -t4 -c100 -d30s http://target-server/

# Test avec attaques simul√©es
wrk -t4 -c100 -d30s -s attack.lua http://target-server/
```

#### Avec Scapy (Couches L3/L4)
```python
# Script Python pour g√©n√©rer des paquets L3/L4
from scapy.all import *

# Envoyer des paquets TCP
send(IP(dst="192.168.1.100")/TCP(dport=22), count=100)

# Simuler une attaque depuis une IP bloqu√©e
send(IP(src="192.42.116.1", dst="192.168.1.100")/TCP(dport=80))
```

### 2. Analyser les R√©sultats

Le syst√®me affiche automatiquement :
```
TIGER-FOX FILTERING PERFORMANCE SUMMARY
========================================
Mode: SEQUENTIAL
Total Packets Processed: 1,247
Packets Dropped: 156 (12.5%)
Packets Accepted: 1,091 (87.5%)
Avg Decision Time: 0.245 ms
P99 Decision Time: 1.230 ms
CPU Usage: 15.4%
Memory Usage: 45.2 MB

Top Rules by Hits:
  block_sqli_attempts: 89 hits, 0.156ms avg
  block_scanner_ua: 34 hits, 0.089ms avg
```

---

## üìñ Comprendre les R√®gles

### Format des R√®gles
Les r√®gles sont d√©finies en JSON et organis√©es par couche OSI :

```json
{
  "rules": [
    {
      "id": "block_tor_ips",           // Identifiant unique
      "layer": 3,                     // Couche OSI (3=IP, 4=TCP/UDP, 7=HTTP)
      "type": "ip_src_in",            // Type de v√©rification
      "values": ["192.42.116.0/24"],  // Valeurs √† v√©rifier
      "action": "drop"                // Action : "drop" ou "accept"
    }
  ]
}
```

### Types de R√®gles Support√©s

#### Layer 3 (IP)
- `ip_src_in` : IP source dans une liste/CIDR
- `ip_dst_in` : IP destination dans une liste/CIDR
- `ip_src_country` : Pays de l'IP source (CN, RU, etc.)

#### Layer 4 (TCP/UDP)
- `tcp_dst_port` : Port TCP de destination
- `udp_dst_port` : Port UDP de destination
- `tcp_flags` : Flags TCP sp√©cifiques

#### Layer 7 (Application)
- `http_uri_regex` : Regex sur l'URI HTTP
- `http_header_contains` : Contenu des headers HTTP
- `http_method` : M√©thode HTTP (GET, POST, etc.)

### Exemples de R√®gles

```json
{
  "rules": [
    // Bloquer les IPs Tor
    {
      "id": "block_tor",
      "layer": 3,
      "type": "ip_src_in",
      "values": ["192.42.116.0/24", "199.87.154.0/24"],
      "action": "drop"
    },
    
    // Bloquer SSH
    {
      "id": "block_ssh",
      "layer": 4,
      "type": "tcp_dst_port",
      "values": [22],
      "action": "drop"
    },
    
    // D√©tecter SQLi
    {
      "id": "detect_sqli",
      "layer": 7,
      "type": "http_uri_regex",
      "values": ["(?i)(union|select).*from"],
      "action": "drop"
    }
  ]
}
```

---

## üî¨ Modes de Fonctionnement D√©taill√©s

### Mode S√©quentiel
```
Paquet arrive ‚Üí L3 rules ‚Üí L4 rules ‚Üí L7 rules ‚Üí D√©cision
                  ‚Üì          ‚Üì          ‚Üì
                DROP?      DROP?      DROP?
```

**Avantages :**
- Simple et pr√©visible
- Consommation m√©moire faible
- D√©bogage facile

**Inconv√©nients :**
- Plus lent pour beaucoup de r√®gles
- N'utilise pas le multic≈ìur

### Mode Hybride (Parall√®le)
```
Paquet arrive ‚Üí [L3 rules] ‚Üí D√©cision
                [L4 rules] ‚Üó
                [L7 rules] ‚Üó
                (en parall√®le)
```

**Avantages :**
- Utilise plusieurs c≈ìurs CPU
- Plus rapide avec beaucoup de r√®gles
- Premi√®re r√®gle qui match gagne

**Inconv√©nients :**
- Plus complexe
- Consommation m√©moire plus √©lev√©e
- Overhead des threads

---

## üìà M√©triques et Monitoring

### M√©triques Collect√©es
- **Latence** : Temps de d√©cision par paquet (P50, P95, P99)
- **Throughput** : Paquets trait√©s par seconde
- **CPU** : Utilisation processeur (user/system)
- **M√©moire** : Consommation RSS et VMS
- **R√®gles** : Fr√©quence d'activation par r√®gle

### Exportation des Donn√©es
```bash
# Les m√©triques sont automatiquement export√©es en JSON
# Fichier : metrics_export_YYYYMMDD_HHMMSS.json
```

### Visualisation
```python
# Script pour analyser les r√©sultats
import json
import matplotlib.pyplot as plt

# Charger les m√©triques
with open('metrics_export.json', 'r') as f:
    data = json.load(f)

# Cr√©er des graphiques
plt.plot(data['time_series']['packets_per_second'])
plt.title('Throughput over time')
plt.show()
```

---

## üõ†Ô∏è D√©veloppement et Extension

### Ajouter un Nouveau Type de R√®gle

1. **Modifier `rule_engine.py`** :
```python
elif rule.type == 'mon_nouveau_type':
    # Votre logique ici
    return ma_condition
```

2. **Ajouter dans `example_rules.json`** :
```json
{
  "id": "ma_regle",
  "layer": 7,
  "type": "mon_nouveau_type",
  "values": ["valeur1", "valeur2"],
  "action": "drop"
}
```

### Optimisations Possibles
- **Cache intelligent** : Mettre en cache les d√©cisions r√©centes
- **Pre-filtering** : R√®gles rapides en premier
- **Regex compilation** : Compiler les regex √† l'avance
- **Memory pooling** : R√©utiliser les objets

---

## üêõ D√©pannage

### Probl√®mes Courants

#### "Permission denied" en lan√ßant le script
```bash
# Solution : Utiliser sudo
sudo python main.py
```

#### "No packets received"
```bash
# V√©rifier les r√®gles iptables
sudo iptables -L -n

# G√©n√©rer du trafic de test
curl http://localhost/test
```

#### "Import error: netfilterqueue"
```bash
# Installer les d√©pendances syst√®me
sudo apt install libnetfilter-queue-dev
pip install netfilterqueue
```

#### Performances d√©grad√©es
```bash
# R√©duire le nombre de r√®gles
# Ou optimiser les r√®gles regex
# Ou augmenter max_workers dans config
```

### Logs de Debug
```bash
# Activer les logs d√©taill√©s
sudo python main.py --verbose

# Surveiller les logs syst√®me
sudo tail -f /var/log/syslog | grep tiger-fox
```

---

## üìö R√©f√©rences et Documentation

### Documentation Technique
- [Netfilter/iptables](https://netfilter.org/documentation/)
- [NFQUEUE](https://netfilter.org/projects/libnetfilter_queue/)
- [Scapy Documentation](https://scapy.readthedocs.io/)

### Articles de Recherche
- Roesch, M. "Snort - Lightweight Intrusion Detection for Networks"
- ModSecurity Documentation
- OWASP Core Rule Set

### Ressources CloudLab
- [CloudLab Portal](https://www.cloudlab.us/)
- [CloudLab Documentation](https://docs.cloudlab.us/)

---

## ü§ù Contribution

### Structure des Commits
```
[COMPONENT] Description courte

Description d√©taill√©e si n√©cessaire

Exemples :
[ENGINE] Optimize regex compilation for L7 rules
[METRICS] Add P99 latency calculation
[DOCS] Update installation instructions
```

### Tests
```bash
# Avant de commit, tester :
sudo python main.py --mode sequential --verbose
sudo python main.py --mode hybrid --verbose

# V√©rifier que les m√©triques sont correctes
```

---

## üìû Support et Contact

**Auteur :** DONFACK PASCAL ARTHUR MONTGOMERY (Tiger Fox)  
**Email :** [votre-email]  
**Projet :** Master en G√©nie Informatique  
**Institution :** [Votre universit√©]

### Issues et Questions
- Cr√©er une issue GitHub pour les bugs
- Utiliser les discussions pour les questions
- Lire d'abord ce README et la documentation

---

## üìÑ License

Ce projet est d√©velopp√© dans le cadre d'un projet de recherche acad√©mique.
Utilisation libre pour la recherche et l'√©ducation.

---

## üéØ Prochaines √âtapes

### Version Actuelle (v1.0)
- [x] Moteur s√©quentiel
- [x] Moteur hybride
- [x] Interface NFQUEUE
- [x] M√©triques basiques

### Prochaines Versions
- [ ] Migration vers C pour les performances
- [ ] Support eBPF/XDP
- [ ] Interface web de monitoring
- [ ] Support des r√®gles Suricata natives
- [ ] Support ModSecurity natif
- [ ] Perspectives quantiques (recherche th√©orique)

---

**Happy Filtering! üöÄ**
